//@version=6
indicator("Harmonic Pattern Detector (Gartley, Bat, Butterfly & Shark) - with Predictions", overlay=true, max_lines_count=500, max_labels_count=500)

// 1. Ustawienia / Inputs
pivotLen            = input.int(5, "Długość pivota", minval=1)
tol                 = input.float(0.05, "Tolerancja (Fib)", step=0.01)
incompleteThreshold = input.float(0.8, "Procent niepełnego paternu do predykacji", step=0.1, minval=0.0, maxval=1.0)
labelOffset         = input.float(10.0, "Offset etykiety (w jednostkach ceny)", step=0.1)
showPatternFill     = input.bool(true, "Show Pattern Fill?")
showRatioLabels     = input.bool(true, "Show Ratio Labels?")
combineRatioLabels  = input.bool(false, "Combine Ratio Labels into one?")
labelSizeChoice     = input.string("small", "Label Size", options=["tiny","small","normal","large"])
onlyLastPattern     = input.bool(false, "Only Last Pattern?")

f_getLabelSize(sz) => sz == "tiny"   ? size.tiny : sz == "small"  ? size.small : sz == "normal" ? size.normal : size.large

labelSize = f_getLabelSize(labelSizeChoice)

// 2. Tablice do przechowywania pivotów i czasu
var pivots       = array.new_float()
var pivotsBars   = array.new_int()
var pivotsTime   = array.new_int()

ph = ta.pivothigh(high, pivotLen, pivotLen)
pl = ta.pivotlow(low, pivotLen, pivotLen)

// Gdy wykryty pivot high - dopisz do tablic
if not na(ph)
    array.push(pivots, ph)
    array.push(pivotsBars, bar_index - pivotLen)
    array.push(pivotsTime, time[pivotLen])

// Gdy wykryty pivot low - dopisz do tablic
if not na(pl)
    array.push(pivots, pl)
    array.push(pivotsBars, bar_index - pivotLen)
    array.push(pivotsTime, time[pivotLen])

// Przechowujemy max 5 pivotów
if array.size(pivots) > 5
    array.shift(pivots)
    array.shift(pivotsBars)
    array.shift(pivotsTime)

// 3. Przechowywanie referencji do obiektów (linie, etykiety)
var lines  = array.new_line()
var labels = array.new_label()

f_clearObjects() =>
    for i = 0 to array.size(lines) - 1
        line.delete(array.get(lines, i))
    array.clear(lines)
    for j = 0 to array.size(labels) - 1
        label.delete(array.get(labels, j))
    array.clear(labels)

// 4. Funkcja rysująca formację
f_drawPattern(_title, _col, X, A, B, C, D, X_bar, A_bar, B_bar, C_bar, D_bar, X_time, A_time, B_time, C_time, D_time, ratioAB, ratioBC, ratioCD, ratioXD) =>
    lXA = line.new(X_bar, X, A_bar, A, color=_col, width=2)
    lAB = line.new(A_bar, A, B_bar, B, color=_col, width=2)
    lBC = line.new(B_bar, B, C_bar, C, color=_col, width=2)
    lCD = line.new(C_bar, C, D_bar, D, color=_col, width=2)
    lDX = line.new(D_bar, D, X_bar, X, color=_col, width=2)
    array.push(lines, lXA)
    array.push(lines, lAB)
    array.push(lines, lBC)
    array.push(lines, lCD)
    array.push(lines, lDX)

    lblX = label.new(X_bar, X + labelOffset, "X", style=label.style_label_left, yloc=yloc.abovebar, color=color.new(_col, 0), textcolor=color.white, size=size.tiny)
    lblA = label.new(A_bar, A + labelOffset, "A", style=label.style_label_left, yloc=yloc.abovebar, color=color.new(_col, 0), textcolor=color.white, size=size.tiny)
    lblB = label.new(B_bar, B + labelOffset, "B", style=label.style_label_left, yloc=yloc.abovebar, color=color.new(_col, 0), textcolor=color.white, size=size.tiny)
    lblC = label.new(C_bar, C + labelOffset, "C", style=label.style_label_left, yloc=yloc.abovebar, color=color.new(_col, 0), textcolor=color.white, size=size.tiny)
    lblD = label.new(D_bar, D + labelOffset, "D", style=label.style_label_left, yloc=yloc.abovebar, color=color.new(_col, 0), textcolor=color.white, size=size.tiny)
    array.push(labels, lblX)
    array.push(labels, lblA)
    array.push(labels, lblB)
    array.push(labels, lblC)
    array.push(labels, lblD)

    if showPatternFill
        linefill.new(lXA, lAB, color.new(_col, 85))
        linefill.new(lAB, lBC, color.new(_col, 85))
        linefill.new(lBC, lCD, color.new(_col, 85))
        linefill.new(lCD, lDX, color.new(_col, 85))

    midPrice = (X + A + B + C + D) / 5.0
    midTime  = (X_time + A_time + B_time + C_time + D_time) / 5
    lblTitle = label.new(int(midTime), midPrice, _title, style=label.style_label_upper_right, xloc=xloc.bar_time, color=color.new(_col, 0), textcolor=color.white, size=labelSize)
    array.push(labels, lblTitle)

    if showRatioLabels
        if combineRatioLabels
            ratioText = str.format("AB/XA={0}\nBC/AB={1}\nCD/BC={2}\nXD/XA={3}", str.tostring(ratioAB, format.mintick), str.tostring(ratioBC, format.mintick), str.tostring(ratioCD, format.mintick), str.tostring(ratioXD, format.mintick))
            ratioMidPrice = (A + B + C + D + X) / 5.0
            ratioMidTime  = (A_time + B_time + C_time + D_time + X_time) / 5
            lblRatio = label.new(int(ratioMidTime), ratioMidPrice, ratioText, style=label.style_label_lower_right, xloc=xloc.bar_time, color=color.new(_col, 0), textcolor=color.white, size=size.tiny)
            array.push(labels, lblRatio)
        else
            lblAB = label.new(int((A_time + B_time) / 2), (A + B) / 2, "AB/XA=" + str.tostring(ratioAB, format.mintick), style=label.style_label_lower_right, xloc=xloc.bar_time, color=color.new(_col, 0), textcolor=color.white, size=size.tiny)
            array.push(labels, lblAB)
            lblBC = label.new(int((B_time + C_time) / 2), (B + C) / 2, "BC/AB=" + str.tostring(ratioBC, format.mintick), style=label.style_label_lower_right, xloc=xloc.bar_time, color=color.new(_col, 0), textcolor=color.white, size=size.tiny)
            array.push(labels, lblBC)
            lblCD = label.new(int((C_time + D_time) / 2), (C + D) / 2, "CD/BC=" + str.tostring(ratioCD, format.mintick), style=label.style_label_lower_right, xloc=xloc.bar_time, color=color.new(_col, 0), textcolor=color.white, size=size.tiny)
            array.push(labels, lblCD)
            lblXD = label.new(int((D_time + X_time) / 2), (D + X) / 2, "XD/XA=" + str.tostring(ratioXD, format.mintick), style=label.style_label_lower_right, xloc=xloc.bar_time, color=color.new(_col, 0), textcolor=color.white, size=size.tiny)
            array.push(labels, lblXD)

// Funkcja pomocnicza do rysowania przewidywanego punktu D (dla niepełnych formacji)
f_drawPredictedD(_title, _col, X, A, B, C, predictedD, X_bar, A_bar, B_bar, C_bar, predictedD_bar) =>
    l = line.new(C_bar, C, predictedD_bar, predictedD, color=_col, style=line.style_dotted, width=2)
    array.push(lines, l)
    lbl = label.new(predictedD_bar, predictedD, _title + "\nPredicted D", style=label.style_label_upper_right, xloc=xloc.bar_index, color=color.new(_col, 0), textcolor=color.white, size=size.tiny)
    array.push(labels, lbl)

// 5. Logika wykrywania pełnych formacji (5 pivotów)
if array.size(pivots) == 5
    X     = array.get(pivots, 0)
    A     = array.get(pivots, 1)
    B     = array.get(pivots, 2)
    C     = array.get(pivots, 3)
    D     = array.get(pivots, 4)
    X_bar = array.get(pivotsBars, 0)
    A_bar = array.get(pivotsBars, 1)
    B_bar = array.get(pivotsBars, 2)
    C_bar = array.get(pivotsBars, 3)
    D_bar = array.get(pivotsBars, 4)
    X_time= array.get(pivotsTime, 0)
    A_time= array.get(pivotsTime, 1)
    B_time= array.get(pivotsTime, 2)
    C_time= array.get(pivotsTime, 3)
    D_time= array.get(pivotsTime, 4)

    XA = math.abs(A - X)
    AB = math.abs(B - A)
    BC = math.abs(C - B)
    CD = math.abs(D - C)
    XD = math.abs(D - X)

    ratioAB = XA != 0 ? AB / XA : na
    ratioBC = AB != 0 ? BC / AB : na
    ratioCD = BC != 0 ? CD / BC : na
    ratioXD = XA != 0 ? XD / XA : na

    isGartley   = (ratioAB >= (0.618 - tol) and ratioAB <= (0.618 + tol)) and (ratioBC >= (0.382 - tol) and ratioBC <= (0.886 + tol)) and (ratioXD >= (0.786 - tol) and ratioXD <= (0.786 + tol))
    isBat       = (ratioAB >= (0.382 - tol) and ratioAB <= (0.50 + tol))  and (ratioBC >= (0.382 - tol) and ratioBC <= (0.886 + tol)) and (ratioXD >= (0.886 - tol) and ratioXD <= (0.886 + tol))
    isButterfly = (ratioAB >= (0.786 - tol) and ratioAB <= (0.786 + tol)) and (ratioBC >= (0.382 - tol) and ratioBC <= (0.886 + tol)) and (ratioXD >= (1.27 - tol) and ratioXD <= (1.27 + tol))

    // Shark
    predictedCShark = X > A ? X - 1.13 * (X - A) : X + 1.13 * (A - X)
    isShark         = (ratioAB >= (0.5 - tol) and ratioAB <= (0.5 + tol)) and (math.abs(D - predictedCShark) <= tol * math.abs(predictedCShark))

    if onlyLastPattern
        f_clearObjects()

    if isGartley
        f_drawPattern("Bullish Gartley Pattern", color.green, X, A, B, C, D, X_bar, A_bar, B_bar, C_bar, D_bar, X_time, A_time, B_time, C_time, D_time, ratioAB, ratioBC, ratioCD, ratioXD)
        targetPrice = X > A ? X - 0.786 * (X - A) : X + 0.786 * (A - X)
        newLine = line.new(D_bar, targetPrice, bar_index, targetPrice, color=color.green, style=line.style_dotted, width=2, extend=extend.right)
        array.push(lines, newLine)

    if isBat
        f_drawPattern("Bullish Bat Pattern", color.blue, X, A, B, C, D, X_bar, A_bar, B_bar, C_bar, D_bar, X_time, A_time, B_time, C_time, D_time, ratioAB, ratioBC, ratioCD, ratioXD)
        targetPrice = X > A ? X - 0.886 * (X - A) : X + 0.886 * (A - X)
        newLine = line.new(D_bar, targetPrice, bar_index, targetPrice, color=color.blue, style=line.style_dotted, width=2, extend=extend.right)
        array.push(lines, newLine)

    if isButterfly
        f_drawPattern("Bullish Butterfly", color.orange, X, A, B, C, D, X_bar, A_bar, B_bar, C_bar, D_bar, X_time, A_time, B_time, C_time, D_time, ratioAB, ratioBC, ratioCD, ratioXD)
        targetPrice = X > A ? X - 1.27 * (X - A) : X + 1.27 * (A - X)
        newLine = line.new(D_bar, targetPrice, bar_index, targetPrice, color=color.orange, style=line.style_dotted, width=2, extend=extend.right)
        array.push(lines, newLine)

    if isShark
        f_drawPattern("Bullish Shark Pattern", color.purple, X, A, B, C, D, X_bar, A_bar, B_bar, C_bar, D_bar, X_time, A_time, B_time, C_time, D_time, ratioAB, ratioBC, ratioCD, ratioXD)
        newLine = line.new(D_bar, predictedCShark, bar_index, predictedCShark, color=color.purple, style=line.style_dotted, width=2, extend=extend.right)
        array.push(lines, newLine)

// 6. Wykrywanie NIEPEŁNYCH (4-punktowych) formacji => PREDYKCJA punktu D
else if array.size(pivots) == 4
    X     = array.get(pivots, 0)
    A     = array.get(pivots, 1)
    B     = array.get(pivots, 2)
    C     = array.get(pivots, 3)
    X_bar = array.get(pivotsBars, 0)
    A_bar = array.get(pivotsBars, 1)
    B_bar = array.get(pivotsBars, 2)
    C_bar = array.get(pivotsBars, 3)
    // Można dać predictedD_bar = bar_index + 1, tutaj używamy samego bar_index
    predictedD_bar = bar_index  

    XA = math.abs(A - X)
    AB = math.abs(B - A)
    BC = math.abs(C - B)

    ratioAB = XA != 0 ? AB / XA : na
    ratioBC = AB != 0 ? BC / AB : na

    // --- PREDYKCYJNY GARTLEY ---
    isPotentialGartley = (ratioAB >= (0.618 - tol) and ratioAB <= (0.618 + tol)) and (ratioBC >= (0.382 - tol) and ratioBC <= (0.886 + tol))
    bcMin = 0.382 - tol
    bcMax = 0.886 + tol
    bcRange = bcMax - bcMin
    bcFill  = (ratioBC - bcMin) / bcRange
    canPredictGartley = isPotentialGartley and (bcFill >= incompleteThreshold)
    if canPredictGartley
        predictedD = X > A ? X - 0.786 * (X - A) : X + 0.786 * (A - X)
        f_drawPredictedD("Potential Gartley", color.new(color.green, 0), X, A, B, C, predictedD, X_bar, A_bar, B_bar, C_bar, predictedD_bar)

    // --- PREDYKCYJNY BAT ---
    isPotentialBat = (ratioAB >= (0.382 - tol) and ratioAB <= (0.50 + tol)) and (ratioBC >= (0.382 - tol) and ratioBC <= (0.886 + tol))
    bcFillBat = (ratioBC - (0.382 - tol)) / ((0.886 + tol) - (0.382 - tol))
    canPredictBat = isPotentialBat and (bcFillBat >= incompleteThreshold)
    if canPredictBat
        predictedD = X > A ? X - 0.886 * (X - A) : X + 0.886 * (A - X)
        f_drawPredictedD("Potential Bat", color.new(color.blue, 0), X, A, B, C, predictedD, X_bar, A_bar, B_bar, C_bar, predictedD_bar)

    // --- PREDYKCYJNY BUTTERFLY ---
    isPotentialButterfly = (ratioAB >= (0.786 - tol) and ratioAB <= (0.786 + tol)) and (ratioBC >= (0.382 - tol) and ratioBC <= (0.886 + tol))
    bcFillButterfly = (ratioBC - (0.382 - tol)) / ((0.886 + tol) - (0.382 - tol))
    canPredictButterfly = isPotentialButterfly and (bcFillButterfly >= incompleteThreshold)
    if canPredictButterfly
        predictedD = X > A ? X - 1.27 * (X - A) : X + 1.27 * (A - X)
        f_drawPredictedD("Potential Butterfly", color.new(color.orange, 0), X, A, B, C, predictedD, X_bar, A_bar, B_bar, C_bar, predictedD_bar)

    // --- PREDYKCYJNY SHARK ---
    isPotentialShark = (ratioAB >= (0.5 - tol) and ratioAB <= (0.5 + tol))
    if isPotentialShark
        predictedDShark = X > A ? X - 1.13 * (X - A) : X + 1.13 * (A - X)
        f_drawPredictedD("Potential Shark", color.new(color.purple, 0), X, A, B, C, predictedDShark, X_bar, A_bar, B_bar, C_bar, predictedD_bar)
